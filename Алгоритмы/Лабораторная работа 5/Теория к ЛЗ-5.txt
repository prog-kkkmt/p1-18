Подготовил: Герасимов Дмитрий П1-18.
Тема: Функции сложности алгоритма
Лабораторная работа №5
Дата: 21.09.2020

Точное время обработки массива определяется из уравнения:
	Действиетельное время (длина массива) = (Длина массива)^2 + 5*(Длина массива) + 100
	Оценка времени (длина массива) = 1,1*(Длина массива)^2
Функция сложности O выражает относительную сложность агоритма в зависимости от некоторой переменной (или переменных).

Существует 3 важных правила для определения функции сложности:
	1. O(k*f) = O(f). - постоянные множетели не имеют значения для определения порядка
сложности. Пример: O(1,5*n) = O(n)
	2. O(f*g) = O(f)*O(g) или O(f/g) = O(f)/O(g). - порядок сложности произведения 2х функций равен 
произведению их сложностей. Пример: O((17*n)*n) = O(17*n)*O(n) = O(n)*O(n) = O(n^2)
	3. O(f+g) = доминанте O(f) и O(g). - порядок суммы функции определяется как порядок доминанты 1го и 2го
слагаемых, т.е выбирается наибольший порядок. Пример: O(n^5 + n^2) = O(n^5)

	ВИДЫ ФУНКЦИИ СЛОЖНОСТИ АЛГОРИТМОВ

	O(1) - в алгоритмах константной сложности большинство операций в программе выполняются один или 
несколько раз. Любой алгоритм, всегда требующий независимо от размера данных одного и того же времени, 
имеет константную сложность.
	O(n) - время работы программы линейно, обычно когда каждый элемент входных данных требуется обработать 
лишь линейное число раз.
	O(n^2), O(n^3), O(n^a) - полиномиальная сложность. O(n^2) - квадратичная сложность, 
O(n^3) - кубическая сложность
	O(log(n)) - когда время работы программы логарифмическое, программа начинает работать намного 
медленнее с увеличением n. Такое время работы встречается обычно в программах, которые делят большую проблему 
на маленькие и решают их по отдельности.
	O(n*log(n)) - такое время работы имеют те алгоритмы, которые делят большую проблему на маленькие, а затем, 
решив их, соединяют их решения.
	O(2^n) - экспоненциальная сложность. Такие алгоритмы чаще всего возникают в результате подхода, 
именуемого методом грубой силы.
PS: Метод грубой силы — метод решения задачи путем перебора всех возможных вариантов.

	ВРЕМЕННАЯ ФУНКЦИЯ СЛОЖНОСТИ

Временная сложность алгоритма может быть подсчитана исходя из анализа его управляющих структур.

	Вид управляющей структуры 	Сложность
	Присваивание			O(1)
	Простое выражение		O(1)
	Si; S2				Доминанта для О(Выч1) и O(Выч2)

	IF Условие THEN		Доминанта для
		S1			O(Выч1) и О(Выч2) и
	ELSE	
		S2			О(ВычУсл)
		
	for (int i = 0; i != n; ++i)	O(N*Выч1)
		S1

Замечание. О(Выч1), О(Выч2) и О(ВычУсл) обозначают соответственно сложность вычисления для S1, S2 
 и для Условия.

Например, рассмотрим алгоритм обработки элементов массива.
	for (int i = 0; i != n; ++i){
		...
	}
Сложность этого алгоритма O(n), т.к тело цикла выполняется N раз, и сложность тела цикла равна 
О(1).
Если один цикл вложен в другой и оба цикла зависят от размера одной и той же переменной, то вся конструкция характеризуется квадратичной сложностью.
	for (int i = 0; i != n; ++i){
		for (int j = 0; j != n; ++j){
			...
		}
	}
Сложность этой программы - O(n^2).

	ОЦЕНКА СЛОЖНОСТИ АЛГОРИТМА

Пифагорова тройка:

	1|for (a = 1; a <= 500; a++)
	2|	for (b = 1; b <= a; b++)
	3|		for (c = 1; c <= b; c++)
	4|		    if (((c*c) + (b*b)) == (a*a))
	5|		        cout << a << " " << b << " " << c << endl;

	Начнем снизу-вверх:
	В 4ой и 5ой строчке сложность алгоритма = O(1)
	Уже в 3ей строчке сложность алгоритма = O(n)
	Во 2ой = O(n^2)
	В 3ей = O(n^3)
	ИТОГ: Сложность алгоритма "Пифагорова тройка" = O(n^3)

Бинарного поиска:

	 1|int left = 0;
	 2|int right = array.Length;
	 3|int mid = 0;
	 4|
	 5|while (left < right)
	 6|{
	 7|	mid = left + (right - left) / 2;
	 8|
	 9|	if (array[mid] == key)
	10|	    return mid;
	11|
	12|	if (array[mid] > key)
	13|	    right = mid;
	14|	else
	15|	    left = mid + 1;
	16|}
	17|int search = -(1 + left);

	Первая итерация цикла имеет дело со всем списком, каждая последующая итерация делит
	пополам размер массива. Поэтому размерами массива является:
		n, n/2^1, n/2^2, n/2^3, n/2^(m-1), n/2^m, n/2^(m+1)
	В конце концов будет такое число m, что:
		n/2^m < 2 или n < 2^(m+1)
	Так как m - это первое целое, для которого n/2" < 2, то должно быть верно
		n/2^(m-1) >= 2 или n < 2^(m+1)
		-----------------------------
		n/2^(m-1) >= 2
		n >= 2/2^(m-1)
		n >= 2^m
		-----------------------------
		Подставим
		2^m <= n или n < 2^(m+1)
	Из этого следует, что
		2^m <= n < 2^(m+1)
	Возьмем логарифм каждой части неравенства и получим
		m <= log2(n) < m + 1
	ИТОГ: O(log2(n))
	
	ТЕОРЕТИЧЕСКАЯ И ПРАКТИЧЕСКАЯ ФУНКЦИИ СЛОЖНОСТИ
	
Примечание: функцию f(n) определяют как O(g(n))
Пример: Определить ф-ию сложности алгоритма по результатам эксперемента:
	n = 6 (где n - количество исходных данных в алгоритме)
	Количество сравниваний = 54
	
	Решение:
	Вначале найдем эксперементальную ф-ию сложности (O). Эксперементальная ф-ия сложности
	алгоритма принимает следующий ряд (т.е все варианты сложностей алгоритма):
		1) a*n
		2) a*n*log2(n)
		3) a*n^2
		4) a*n^3
		5) a*e^n
		6) a*n!
	1) Рассмотрим первый вариант
		a*n = 54
		6*a = 54
		a = 54/6
	Не подходит, т.к не удовлетворяет условию 1 <= a <= 2
	
	2) Рассмотрим второй вариант
		a*n*log2(n) = 54
		a*6*log2(6) = 54
		a = 54 / (6*log2(6))
		a = 9 / log2(6)
	Не подходит, т.к не удовлетворяет условию -1 <= a <= 2

	3) Рассмотрим третий вариант
		a*n^2 = 54
		a*36 = 54
		a = 54/36 = 1.5
	Подходит, т.к удовлетворяет условию a < 2
	
	Эксперементальная ф-ия сложности: O(1.5*n^2)
	Теоретическая ф-ия сложности: O(n^2)


